{"file":"/Users/qidanta/Documents/personal/rematch-observable/test/ofType.test.ts","mappings":";;AAAA,gCAA+B;AAC/B,+BAA8B;AAC9B,gEAA4D;AAC5D,mCAA0C;AAE1C,MAAM,MAAM,GAAG;IACb,MAAM,EAAN,cAAM;IACN,QAAQ,EAAR,gBAAQ;CACT,CAAA;AAED,MAAM,WAAW,GAAG,+BAAc,CAAC,MAAM,CAAC,CAAA;AAE1C,QAAQ,CAAC,QAAQ,EAAE,GAAG,EAAE;IACtB,IAAI,CAAC,8BAA8B,EAAE,GAAG,EAAE;QACxC,IAAI,OAAO,GAAG,IAAI,cAAO,EAAE,CAAA;QAC3B,IAAI,IAAI,GAAU,EAAE,CAAA;QAEpB,OAAO,CAAC,IAAI,CAAC,YAAM,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,CAAQ,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;QACtF,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAA;QAC7C,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,kBAAkB,EAAE,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC,CAAA;IAClE,CAAC,CAAC,CAAA;IAEF,IAAI,CAAC,iCAAiC,EAAE,GAAG,EAAE;QAC3C,IAAI,OAAO,GAAG,IAAI,cAAO,EAAE,CAAA;QAC3B,IAAI,IAAI,GAAU,EAAE,CAAA;QAEpB,OAAO,CAAC,IAAI,CAAC,YAAM,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,EAAE,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAQ,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;QACtH,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAA;QAC7C,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,kBAAkB,EAAE,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC,CAAA;QAChE,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC,CAAA;QAC9C,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,kBAAkB,EAAE,OAAO,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,oBAAoB,EAAE,CAAC,CAAC,CAAA;IAClG,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA","names":[],"sources":["/Users/qidanta/Documents/personal/rematch-observable/test/ofType.test.ts"],"sourcesContent":["import { ofType } from '../src'\nimport { Subject } from 'rxjs'\nimport { getDispatchers } from '../src/utils/getDispatchers'\nimport { sharks, dolphins } from './utils'\n\nconst models = {\n  sharks,\n  dolphins,\n}\n\nconst dispatchers = getDispatchers(models)\n\ndescribe('ofType', () => {\n  test('should filter by action type', () => {\n    let actions = new Subject()\n    let lulz: any[] = []\n\n    actions.pipe(ofType(dispatchers.sharks.increment) as any).subscribe(x => lulz.push(x))\n    actions.next(dispatchers.sharks.increment(1))\n    expect(lulz).toEqual([{ type: 'sharks/increment', payload: 1 }])\n  })\n\n  test('should filter by multiple types', () => {\n    let actions = new Subject()\n    let lulz: any[] = []\n\n    actions.pipe(ofType(dispatchers.sharks.increment, dispatchers.dolphins.increment) as any).subscribe(x => lulz.push(x))\n    actions.next(dispatchers.sharks.increment(1))\n    expect(lulz).toEqual([{ type: 'sharks/increment', payload: 1 }])\n    actions.next(dispatchers.dolphins.increment())\n    expect(lulz).toEqual([{ type: 'sharks/increment', payload: 1 }, { type: 'dolphins/increment' }])\n  })\n})\n"],"version":3}